"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose-unique-validator";
exports.ids = ["vendor-chunks/mongoose-unique-validator"];
exports.modules = {

/***/ "(rsc)/./node_modules/mongoose-unique-validator/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/mongoose-unique-validator/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst each = __webpack_require__(/*! lodash.foreach */ \"(rsc)/./node_modules/lodash.foreach/index.js\");\r\nconst get = __webpack_require__(/*! lodash.get */ \"(rsc)/./node_modules/lodash.get/index.js\");\r\nconst merge = __webpack_require__(/*! lodash.merge */ \"(rsc)/./node_modules/lodash.merge/index.js\");\r\n\r\n// Function typecheck helper\r\nconst isFunc = (val) => typeof val === 'function';\r\n\r\nconst deepPath = function(schema, pathName) {\r\n    let path;\r\n    const paths = pathName.split('.');\r\n\r\n    if (paths.length > 1) {\r\n        pathName = paths.shift();\r\n    }\r\n\r\n    if (isFunc(schema.path)) {\r\n        path = schema.path(pathName);\r\n    }\r\n\r\n    if (path && path.schema) {\r\n        path = deepPath(path.schema, paths.join('.'));\r\n    }\r\n\r\n    return path;\r\n};\r\n\r\nconst plugin = function(schema, options) {\r\n    options = options || {};\r\n    const type = options.type || plugin.defaults.type || 'unique';\r\n    const message = options.message || plugin.defaults.message || 'Error, expected `{PATH}` to be unique. Value: `{VALUE}`';\r\n\r\n    // Mongoose Schema objects don't describe default _id indexes\r\n    // https://github.com/Automattic/mongoose/issues/5998\r\n    const indexes = [[{ _id: 1 }, { unique: true }]].concat(schema.indexes());\r\n\r\n    // Dynamically iterate all indexes\r\n    each(indexes, (index) => {\r\n        const indexOptions = index[1];\r\n\r\n        if (indexOptions.unique) {\r\n            const paths = Object.keys(index[0]);\r\n            each(paths, (pathName) => {\r\n                // Choose error message\r\n                const pathMessage = typeof indexOptions.unique === 'string' ? indexOptions.unique : message;\r\n\r\n                // Obtain the correct path object\r\n                const path = deepPath(schema, pathName) || schema.path(pathName);\r\n\r\n                if (path) {\r\n                    // Add an async validator\r\n                    path.validate(function() {\r\n                        return new Promise((resolve, reject) => {\r\n                            const isQuery = this.constructor.name === 'Query';\r\n                            const conditions = {};\r\n                            let model;\r\n\r\n                            if (isQuery) {\r\n                                // If the doc is a query, this is a findAndUpdate.\r\n                                each(paths, (name) => {\r\n                                    let pathValue = get(this, '_update.' + name) || get(this, '_update.$set.' + name);\r\n\r\n                                    // Wrap with case-insensitivity\r\n                                    if (get(path, 'options.uniqueCaseInsensitive') || indexOptions.uniqueCaseInsensitive) {\r\n                                        // Escape RegExp chars\r\n                                        pathValue = pathValue.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\r\n                                        pathValue = new RegExp('^' + pathValue + '$', 'i');\r\n                                    }\r\n\r\n                                    conditions[name] = pathValue;\r\n                                });\r\n\r\n                                // Use conditions the user has with find*AndUpdate\r\n                                each(this._conditions, (value, key) => {\r\n                                    conditions[key] = { $ne: value };\r\n                                });\r\n\r\n                                model = this.model;\r\n                            } else {\r\n                                const parentDoc = this.$parent();\r\n                                const isNew = parentDoc.isNew;\r\n\r\n                                if (!isNew && !parentDoc.isModified(pathName)) {\r\n                                    return resolve(true);\r\n                                }\r\n\r\n                                // https://mongoosejs.com/docs/subdocs.html#subdocuments-versus-nested-paths\r\n                                const isSubdocument = this._id !== parentDoc._id;\r\n                                const isNestedPath = isSubdocument ? false : pathName.split('.').length > 1;\r\n\r\n                                each(paths, (name) => {\r\n                                    let pathValue;\r\n                                    if (isSubdocument) {\r\n                                        pathValue = get(this, name.split('.').pop());\r\n                                    } else if (isNestedPath) {\r\n                                        const keys = name.split('.');\r\n                                        pathValue = get(this, keys[0]);\r\n                                        for (let i = 1; i < keys.length; i++) {\r\n                                            const key = keys[i];\r\n                                            pathValue = get(pathValue, key);\r\n                                        }\r\n                                    } else {\r\n                                        pathValue = get(this, name);\r\n                                    }\r\n\r\n                                    // Wrap with case-insensitivity\r\n                                    if (get(path, 'options.uniqueCaseInsensitive') || indexOptions.uniqueCaseInsensitive) {\r\n                                        // Escape RegExp chars\r\n                                        pathValue = pathValue.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\r\n                                        pathValue = new RegExp('^' + pathValue + '$', 'i');\r\n                                    }\r\n\r\n                                    conditions[name] = pathValue;\r\n                                });\r\n\r\n                                if (!isNew && this._id) {\r\n                                    conditions._id = { $ne: this._id };\r\n                                }\r\n\r\n                                // Obtain the model depending on context\r\n                                // https://github.com/Automattic/mongoose/issues/3430\r\n                                // https://github.com/Automattic/mongoose/issues/3589\r\n                                if (isSubdocument) {\r\n                                    model = this.ownerDocument().model(this.ownerDocument().constructor.modelName);\r\n                                } else if (isFunc(this.model)) {\r\n                                    model = this.model(this.constructor.modelName);\r\n                                } else {\r\n                                    model = this.constructor.model(this.constructor.modelName);\r\n                                }\r\n                            }\r\n\r\n                            if (indexOptions.partialFilterExpression) {\r\n                                merge(conditions, indexOptions.partialFilterExpression);\r\n                            }\r\n\r\n                            // Is this model a discriminator and the unique index is on the whole collection,\r\n                            // not just the instances of the discriminator? If so, use the base model to query.\r\n                            // https://github.com/Automattic/mongoose/issues/4965\r\n                            // eslint-disable-next-line\r\n                            if (model.baseModelName && (indexOptions.partialFilterExpression === null || indexOptions.partialFilterExpression === undefined)) {\r\n                                model = model.db.model(model.baseModelName);\r\n                            }\r\n\r\n                            model.find(conditions).countDocuments()\r\n                                .then((count) => {\r\n                                    resolve(count === 0);\r\n                                })\r\n                                .catch((err) => {\r\n                                    reject(err);\r\n                                });\r\n                        });\r\n                    }, pathMessage, type);\r\n                }\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nplugin.defaults = {};\r\n\r\n// Export the mongoose plugin\r\nmodule.exports = plugin;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UtdW5pcXVlLXZhbGlkYXRvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLG9FQUFnQjtBQUNyQyxZQUFZLG1CQUFPLENBQUMsNERBQVk7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLGdFQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsS0FBSyx5QkFBeUIsTUFBTTtBQUN6SDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxJQUFJLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9tZWdhZ2lnL0Rlc2t0b3AvTUVSTi9tdWx0aXVzZXJibG9nL25vZGVfbW9kdWxlcy9tb25nb29zZS11bmlxdWUtdmFsaWRhdG9yL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGVhY2ggPSByZXF1aXJlKCdsb2Rhc2guZm9yZWFjaCcpO1xyXG5jb25zdCBnZXQgPSByZXF1aXJlKCdsb2Rhc2guZ2V0Jyk7XHJcbmNvbnN0IG1lcmdlID0gcmVxdWlyZSgnbG9kYXNoLm1lcmdlJyk7XHJcblxyXG4vLyBGdW5jdGlvbiB0eXBlY2hlY2sgaGVscGVyXHJcbmNvbnN0IGlzRnVuYyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XHJcblxyXG5jb25zdCBkZWVwUGF0aCA9IGZ1bmN0aW9uKHNjaGVtYSwgcGF0aE5hbWUpIHtcclxuICAgIGxldCBwYXRoO1xyXG4gICAgY29uc3QgcGF0aHMgPSBwYXRoTmFtZS5zcGxpdCgnLicpO1xyXG5cclxuICAgIGlmIChwYXRocy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgcGF0aE5hbWUgPSBwYXRocy5zaGlmdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0Z1bmMoc2NoZW1hLnBhdGgpKSB7XHJcbiAgICAgICAgcGF0aCA9IHNjaGVtYS5wYXRoKHBhdGhOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGF0aCAmJiBwYXRoLnNjaGVtYSkge1xyXG4gICAgICAgIHBhdGggPSBkZWVwUGF0aChwYXRoLnNjaGVtYSwgcGF0aHMuam9pbignLicpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGF0aDtcclxufTtcclxuXHJcbmNvbnN0IHBsdWdpbiA9IGZ1bmN0aW9uKHNjaGVtYSwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlIHx8IHBsdWdpbi5kZWZhdWx0cy50eXBlIHx8ICd1bmlxdWUnO1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBwbHVnaW4uZGVmYXVsdHMubWVzc2FnZSB8fCAnRXJyb3IsIGV4cGVjdGVkIGB7UEFUSH1gIHRvIGJlIHVuaXF1ZS4gVmFsdWU6IGB7VkFMVUV9YCc7XHJcblxyXG4gICAgLy8gTW9uZ29vc2UgU2NoZW1hIG9iamVjdHMgZG9uJ3QgZGVzY3JpYmUgZGVmYXVsdCBfaWQgaW5kZXhlc1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzU5OThcclxuICAgIGNvbnN0IGluZGV4ZXMgPSBbW3sgX2lkOiAxIH0sIHsgdW5pcXVlOiB0cnVlIH1dXS5jb25jYXQoc2NoZW1hLmluZGV4ZXMoKSk7XHJcblxyXG4gICAgLy8gRHluYW1pY2FsbHkgaXRlcmF0ZSBhbGwgaW5kZXhlc1xyXG4gICAgZWFjaChpbmRleGVzLCAoaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBpbmRleE9wdGlvbnMgPSBpbmRleFsxXTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4T3B0aW9ucy51bmlxdWUpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhpbmRleFswXSk7XHJcbiAgICAgICAgICAgIGVhY2gocGF0aHMsIChwYXRoTmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hvb3NlIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhNZXNzYWdlID0gdHlwZW9mIGluZGV4T3B0aW9ucy51bmlxdWUgPT09ICdzdHJpbmcnID8gaW5kZXhPcHRpb25zLnVuaXF1ZSA6IG1lc3NhZ2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT2J0YWluIHRoZSBjb3JyZWN0IHBhdGggb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVlcFBhdGgoc2NoZW1hLCBwYXRoTmFtZSkgfHwgc2NoZW1hLnBhdGgocGF0aE5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFuIGFzeW5jIHZhbGlkYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGgudmFsaWRhdGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1F1ZXJ5ID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUXVlcnknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGVsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRvYyBpcyBhIHF1ZXJ5LCB0aGlzIGlzIGEgZmluZEFuZFVwZGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoKHBhdGhzLCAobmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aFZhbHVlID0gZ2V0KHRoaXMsICdfdXBkYXRlLicgKyBuYW1lKSB8fCBnZXQodGhpcywgJ191cGRhdGUuJHNldC4nICsgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIHdpdGggY2FzZS1pbnNlbnNpdGl2aXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXQocGF0aCwgJ29wdGlvbnMudW5pcXVlQ2FzZUluc2Vuc2l0aXZlJykgfHwgaW5kZXhPcHRpb25zLnVuaXF1ZUNhc2VJbnNlbnNpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXNjYXBlIFJlZ0V4cCBjaGFyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFZhbHVlID0gcGF0aFZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCAnXFxcXCQmJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSBuZXcgUmVnRXhwKCdeJyArIHBhdGhWYWx1ZSArICckJywgJ2knKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uc1tuYW1lXSA9IHBhdGhWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGNvbmRpdGlvbnMgdGhlIHVzZXIgaGFzIHdpdGggZmluZCpBbmRVcGRhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoKHRoaXMuX2NvbmRpdGlvbnMsICh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnNba2V5XSA9IHsgJG5lOiB2YWx1ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IHRoaXMubW9kZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudERvYyA9IHRoaXMuJHBhcmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTmV3ID0gcGFyZW50RG9jLmlzTmV3O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmV3ICYmICFwYXJlbnREb2MuaXNNb2RpZmllZChwYXRoTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc3ViZG9jcy5odG1sI3N1YmRvY3VtZW50cy12ZXJzdXMtbmVzdGVkLXBhdGhzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTdWJkb2N1bWVudCA9IHRoaXMuX2lkICE9PSBwYXJlbnREb2MuX2lkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTmVzdGVkUGF0aCA9IGlzU3ViZG9jdW1lbnQgPyBmYWxzZSA6IHBhdGhOYW1lLnNwbGl0KCcuJykubGVuZ3RoID4gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChwYXRocywgKG5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGhWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ViZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9IGdldCh0aGlzLCBuYW1lLnNwbGl0KCcuJykucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmVzdGVkUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IG5hbWUuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9IGdldCh0aGlzLCBrZXlzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFZhbHVlID0gZ2V0KHBhdGhWYWx1ZSwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9IGdldCh0aGlzLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCB3aXRoIGNhc2UtaW5zZW5zaXRpdml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0KHBhdGgsICdvcHRpb25zLnVuaXF1ZUNhc2VJbnNlbnNpdGl2ZScpIHx8IGluZGV4T3B0aW9ucy51bmlxdWVDYXNlSW5zZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzY2FwZSBSZWdFeHAgY2hhcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9IHBhdGhWYWx1ZS5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcXFwkJicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFZhbHVlID0gbmV3IFJlZ0V4cCgnXicgKyBwYXRoVmFsdWUgKyAnJCcsICdpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnNbbmFtZV0gPSBwYXRoVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOZXcgJiYgdGhpcy5faWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucy5faWQgPSB7ICRuZTogdGhpcy5faWQgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9idGFpbiB0aGUgbW9kZWwgZGVwZW5kaW5nIG9uIGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9pc3N1ZXMvMzQzMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy8zNTg5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ViZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSB0aGlzLm93bmVyRG9jdW1lbnQoKS5tb2RlbCh0aGlzLm93bmVyRG9jdW1lbnQoKS5jb25zdHJ1Y3Rvci5tb2RlbE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jKHRoaXMubW9kZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsID0gdGhpcy5tb2RlbCh0aGlzLmNvbnN0cnVjdG9yLm1vZGVsTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSB0aGlzLmNvbnN0cnVjdG9yLm1vZGVsKHRoaXMuY29uc3RydWN0b3IubW9kZWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlKGNvbmRpdGlvbnMsIGluZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBtb2RlbCBhIGRpc2NyaW1pbmF0b3IgYW5kIHRoZSB1bmlxdWUgaW5kZXggaXMgb24gdGhlIHdob2xlIGNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QganVzdCB0aGUgaW5zdGFuY2VzIG9mIHRoZSBkaXNjcmltaW5hdG9yPyBJZiBzbywgdXNlIHRoZSBiYXNlIG1vZGVsIHRvIHF1ZXJ5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzQ5NjVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmJhc2VNb2RlbE5hbWUgJiYgKGluZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiA9PT0gbnVsbCB8fCBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IG1vZGVsLmRiLm1vZGVsKG1vZGVsLmJhc2VNb2RlbE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmZpbmQoY29uZGl0aW9ucykuY291bnREb2N1bWVudHMoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChjb3VudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNvdW50ID09PSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBwYXRoTWVzc2FnZSwgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxucGx1Z2luLmRlZmF1bHRzID0ge307XHJcblxyXG4vLyBFeHBvcnQgdGhlIG1vbmdvb3NlIHBsdWdpblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBsdWdpbjtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mongoose-unique-validator/index.js\n");

/***/ })

};
;